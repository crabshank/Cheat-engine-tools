 <html>
 <head>
 </head>
 <body>
 <title>CETRACE Reader</title>
 <h1 style="text-align: center;">CETRACE Reader (x64)</h1>
 <label for="openFile1">Load file: </label><input  type="file" id="openFile1" style="margin-left: 4px;vertical-align: top;"></input>
 <section id="instructions"></section>
 <section id="search">
     <label for="search">Hex: </label>
 <input id="search"  type="text"></input>
 <select id="types"></select>
 </section>
 <style>
div.trackable {
    display: contents !important;
}
section.register {
    display: grid !important;
    grid-auto-columns: max-content !important;
}
 </style>
  <script>
  
const lookup_hex=[
									"00",
									"01",
									"02",
									"03",
									"04",
									"05",
									"06",
									"07",
									"08",
									"09",
									"0A",
									"0B",
									"0C",
									"0D",
									"0E",
									"0F",
									"10",
									"11",
									"12",
									"13",
									"14",
									"15",
									"16",
									"17",
									"18",
									"19",
									"1A",
									"1B",
									"1C",
									"1D",
									"1E",
									"1F",
									"20",
									"21",
									"22",
									"23",
									"24",
									"25",
									"26",
									"27",
									"28",
									"29",
									"2A",
									"2B",
									"2C",
									"2D",
									"2E",
									"2F",
									"30",
									"31",
									"32",
									"33",
									"34",
									"35",
									"36",
									"37",
									"38",
									"39",
									"3A",
									"3B",
									"3C",
									"3D",
									"3E",
									"3F",
									"40",
									"41",
									"42",
									"43",
									"44",
									"45",
									"46",
									"47",
									"48",
									"49",
									"4A",
									"4B",
									"4C",
									"4D",
									"4E",
									"4F",
									"50",
									"51",
									"52",
									"53",
									"54",
									"55",
									"56",
									"57",
									"58",
									"59",
									"5A",
									"5B",
									"5C",
									"5D",
									"5E",
									"5F",
									"60",
									"61",
									"62",
									"63",
									"64",
									"65",
									"66",
									"67",
									"68",
									"69",
									"6A",
									"6B",
									"6C",
									"6D",
									"6E",
									"6F",
									"70",
									"71",
									"72",
									"73",
									"74",
									"75",
									"76",
									"77",
									"78",
									"79",
									"7A",
									"7B",
									"7C",
									"7D",
									"7E",
									"7F",
									"80",
									"81",
									"82",
									"83",
									"84",
									"85",
									"86",
									"87",
									"88",
									"89",
									"8A",
									"8B",
									"8C",
									"8D",
									"8E",
									"8F",
									"90",
									"91",
									"92",
									"93",
									"94",
									"95",
									"96",
									"97",
									"98",
									"99",
									"9A",
									"9B",
									"9C",
									"9D",
									"9E",
									"9F",
									"A0",
									"A1",
									"A2",
									"A3",
									"A4",
									"A5",
									"A6",
									"A7",
									"A8",
									"A9",
									"AA",
									"AB",
									"AC",
									"AD",
									"AE",
									"AF",
									"B0",
									"B1",
									"B2",
									"B3",
									"B4",
									"B5",
									"B6",
									"B7",
									"B8",
									"B9",
									"BA",
									"BB",
									"BC",
									"BD",
									"BE",
									"BF",
									"C0",
									"C1",
									"C2",
									"C3",
									"C4",
									"C5",
									"C6",
									"C7",
									"C8",
									"C9",
									"CA",
									"CB",
									"CC",
									"CD",
									"CE",
									"CF",
									"D0",
									"D1",
									"D2",
									"D3",
									"D4",
									"D5",
									"D6",
									"D7",
									"D8",
									"D9",
									"DA",
									"DB",
									"DC",
									"DD",
									"DE",
									"DF",
									"E0",
									"E1",
									"E2",
									"E3",
									"E4",
									"E5",
									"E6",
									"E7",
									"E8",
									"E9",
									"EA",
									"EB",
									"EC",
									"ED",
									"EE",
									"EF",
									"F0",
									"F1",
									"F2",
									"F3",
									"F4",
									"F5",
									"F6",
									"F7",
									"F8",
									"F9",
									"FA",
									"FB",
									"FC",
									"FD",
									"FE",
									"FF"
								];
								
	function n_byte_unit8_to_int(a){
				let out=a[0];
				let bsi=0;
				for(let i=1, len=a.length; i<len; i++){
					bsi+=8;
					let n=a[i]<<bsi;
					out+=n;
				}
				return out;
	}
	
function get_subarray(a, f, t) {
    return a.slice(f, t+1);
}

function getBarSepStr(a,m,x){
	let out='';
	for(let i=0, len=a.length; i<len; i++){
		if(typeof a[i]==='number'){
			out+=a[i].toLocaleString('en-GB',
					{
						useGrouping: false,
						minimumFractionDigits: m,
						maximumFractionDigits: x
					});
		}else if(typeof a[i]==='string'){
			out+='"'+a[i]+'"';
		}else{
			out+='"'+JSON.stringify(a[i])+'"';
		}
		out+=( (i==len-1)? '' : ' | ' );
	}
	return out;
}

function hexProc(b_ints){
	var reg_names=["r10d","r10w","r10b","r11d","r11w","r11b","r12d","r12w","r12b","r13d","r13w","r13b","r14d","r14w","r14b","r15d","r15w","r15b","rax","eax","rbx","ebx","rcx","ecx","rdx","edx","rsi","esi","sil","rdi","edi","dil","rbp","ebp","bpl","rsp","esp","spl","r8d","r8w","r8b","r9d","r9w","r9b","r10","r11","r12","r13","r14","r15","ax","al","bx","bl","cx","cl","dx","dl","si","di","bp","sp","r8","r9"]; //sorted by length
	var inst_HTML=document.querySelector('section#instructions');
	var slc=document.querySelector('select#types');
	inst_HTML.appendChild(document.createElement('br'));
	var all_instructs=[];
	var disp_instructs=[];
	var txt_len_b=[b_ints[4],b_ints[5],b_ints[6],b_ints[7]];
	var txt_len=n_byte_unit8_to_int(txt_len_b);
	var cnt=0;
	// Got opcodes list length
	let sub_instr=[];
	for(let i=8, len=8+txt_len; i<len; i++){
		if(b_ints[i]==13 && b_ints[i+1]==10){
			if(b_ints[i+2]==9){
				i=i+2;
			}else{
				i=i+1;
			}		
		}else{
			if(b_ints[i+1]==13 && b_ints[i+2]==10){
				disp_instructs.push(String.fromCharCode(...sub_instr));
				sub_instr=[];
				i=i+2; //takes us to one element past the past the "0A" in "0D 0A"
			}else{
				sub_instr.push(b_ints[i]);
			}
		}
	}
	
	//b_ints[8+txt_len] is one element past the "0A" in "0D 0A" at the end of the opcodes list
	let strt=-1;
	
	for(let i=8+txt_len, len=b_ints.length-3; i<len; i++){
		let c=b_ints[i];
		if(c>0){
			strt=i+4; // To start of instruction text
			i=b_ints.length-4;
		}
	}
	
if(strt>=0){
	var pos=strt-4;
	while (pos<b_ints.length){

		let curr={inst_len:0, instr_txt:"",instr_txt_b:[], ref_addr:"",r_reg: ["0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0"],r_reg_b: [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]], r_reg_nm:["RAX","RCX","RDX","RBX","RSP","RBP","RSI","RDI","R8","R9","R10","R11","R12","R13","R14","R15","RIP"], r_reg_interp: [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]], x_reg:["0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0"], x_reg_b:[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],  x_reg_interp:[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]], x_reg_nm:["xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm6","xmm7","xmm8","xmm9","xmm10","xmm11","xmm12","xmm13","xmm14","xmm15"],ref_addr_byte_len:0, ref_addr_bytes: "", stack_len: 0, stack:[], stack_b:[]};
		
					curr.inst_len=n_byte_unit8_to_int([b_ints[pos],b_ints[pos+1],b_ints[pos+2],b_ints[pos+3]]);
		
		let char_arr=[];
		
		pos+=4;
	//pos is now at first byte of  instruction

		char_arr=get_subarray(b_ints,pos,pos+curr.inst_len-1);
		curr.instr_txt=String.fromCharCode(...char_arr);
		curr.instr_txt_b=char_arr;
		console.log(curr.instr_txt);
		pos=curr.inst_len+pos+4;
		
		
		for(let i=7 ; i>=0; i--){
			curr.ref_addr=curr.ref_addr.concat(lookup_hex[b_ints[i+pos]]);
		}
		
		//pos +8 +120 is the first byte of the registers
		pos+=128;
		
		for(let k=0, len=curr.r_reg.length; k<len; k++){
			for(let i=7 ; i>=0; i--){
				curr.r_reg[k]=curr.r_reg[k].concat(lookup_hex[b_ints[i+pos]]);
				curr.r_reg_b[k].unshift(b_ints[i+pos]);
			}
			pos+=8;
		}
		
		//swap around to match CE tracer output:
		curr.r_reg=[curr.r_reg[0],curr.r_reg[3],curr.r_reg[1],curr.r_reg[2],...get_subarray(curr.r_reg,4,16)];
		
		curr.r_reg_b=[curr.r_reg_b[0],curr.r_reg_b[3],curr.r_reg_b[1],curr.r_reg_b[2],...get_subarray(curr.r_reg_b,4,16)];
		
		curr.r_reg_nm=[curr.r_reg_nm[0],curr.r_reg_nm[3],curr.r_reg_nm[1],curr.r_reg_nm[2],...get_subarray(curr.r_reg_nm,4,16)];

		let b_interp=[1,2,4,8];
		
		for(let i=0, len_i=curr.r_reg_b.length ; i<len_i; i++){
			for(let j=0, len_j=b_interp.length ; j<len_j; j++){
				curr.r_reg_interp[i].push( n_byte_unit8_to_int( get_subarray(curr.r_reg_b[i], 0, b_interp[j]-1) ) );
			}
			curr.r_reg_interp[i].push(String.fromCharCode(...curr.r_reg_b[i]));
		}
		
		pos+=160;
		
		//pos is now at first byte of  xmm registers
		for(let k=0, len=curr.x_reg.length; k<len; k++){
			for(let i=15 ; i>=0; i--){
				curr.x_reg[k]=curr.x_reg[k].concat(lookup_hex[b_ints[i+pos]]);
				curr.x_reg_b[k].unshift(b_ints[i+pos]);
			}
			pos+=16;
		}
		
		for(let x=0, len=curr.x_reg_b.length; x<len; x++){ //bytes: 1,2,4,8,string,float2, double2
				let data, view;
				//float4
				let f4=[];
				for(let b=0; b<16; b+=4){
					data =  get_subarray(curr.x_reg_b[x], b, b+3).reverse();
					view = new DataView(new Uint8Array(data).buffer);
					view.getFloat32(0,false);
					f4.push(view.getFloat32(0)); //will be rounded later
				}
				curr.x_reg_interp[x].push(f4);
				//double2
				let d2=[];
				for(let b=0; b<16; b+=8){
					data = get_subarray(curr.x_reg_b[x], b, b+7).reverse();
					view = new DataView(new Uint8Array(data).buffer);
					d2.push(view.getFloat64(0,false));
				}
				curr.x_reg_interp[x].push(d2);
		}

		pos+=560;
		
		//pos is now at first byte of bytesize (8 bytes)
		
		curr.ref_addr_byte_len=n_byte_unit8_to_int([b_ints[pos],b_ints[pos+1],b_ints[pos+2],b_ints[pos+3],b_ints[pos+4],b_ints[pos+5],b_ints[pos+6],b_ints[pos+7]]);
		
		pos+=8;
		
		//pos is now at first byte of ref_address bytes
		if(curr.ref_addr_byte_len>0){
			for(let j=curr.ref_addr_byte_len-1; j>=0; j--){
					curr.ref_addr_bytes=curr.ref_addr_bytes.concat(lookup_hex[b_ints[j+pos]]);
			}
		}
		
		pos+=curr.ref_addr_byte_len;
		
		//pos is now at first byte of stack length
		
		curr.stack_len=n_byte_unit8_to_int([b_ints[pos],b_ints[pos+1],b_ints[pos+2],b_ints[pos+3],b_ints[pos+4],b_ints[pos+5],b_ints[pos+6],b_ints[pos+7]])/8;
		// div by 8 as stack entries are 8 bytes long
		pos+=8;
		//pos is now at first byte of stack 
		
		for(let k=0, len=curr.stack_len; k<len; k++){
		let stk="";
		let stk_b=[];
			for(let i=7; i>=0; i--){
					stk=stk.concat(lookup_hex[b_ints[i+pos]]);
					stk_b.unshift(b_ints[i+pos]);
			}
			curr.stack.push(stk);
			curr.stack_b.push(stk_b);
			pos+=8;
		}			
		//pos is now at first byte of next instruction
		all_instructs.push(curr);
	}
		console.log(all_instructs);
		
		var inst_lens_eq=(disp_instructs.length==all_instructs.length)?true:false;
		
		for(let k=0, len=all_instructs.length; k<len; k++){
		let curr=all_instructs[k];
			let instr=document.createElement('SECTION');
			instr.className='instruction_HTML';
			let instruc_txt=document.createElement('SECTION');
			instr.className='instruction_text_HTML';
			let spl=curr.instr_txt.split(' ');
			let inst_nm=spl[0];
			let spl2=spl.slice(1).join(' ');
			let args=spl2.split(',');
			let rgs=[];
				for(let i=0, len_i=args.length; i<len_i; i++){
					let a=args[i].trim();
					let a_l=a.toLocaleLowerCase();
					for(let j=0, len_j=reg_names.length; j<len_j; j++){
						a=args[i];
						a_l=args[i];
						let cr=reg_names[j];
						let ix=a_l.indexOf(cr);
						let ridv=rgs.some((r)=>{return r.includes(cr);});
							if(ix>=0 && !ridv){
								let str='';
								for(let x=0, len_x=cr.length; x<len_x; x++){
									str+=a[ix+x];
								}
								rgs.push(str);
							}
					}
					
					//for "[address]"
					for(let x=0, len_x=args[i].length; x<len_x; x++){
						if(args[i][x]=='[' && x<len_x-2){
						let str='[';
							for(let y=x+1, len_y=args[i].length; y<len_y; y++){
								str+=args[i][y];
								if(args[i][y]==']' ){
									rgs.unshift(str);
									y=args[i].length-1;
									x=y;
								}
							}
						}
					}
					
					for(let x=0, len_x=rgs.length; x<len_x; x++){
						args[i]=args[i].split(rgs[x]).join('<div class="trackable">'+rgs[x]+'</div>');
					}
				}
				
				
				instr.innerHTML=(  (inst_lens_eq)?( disp_instructs[k].split(' -')[0]+' ('+curr.r_reg[16]+')'  ):  curr.r_reg[16] )+': '+
				(	( curr.ref_addr==="0000000000000000")?
					'':
					'<br>Referenced address: '  + curr.ref_addr
				)+
				'<br>'+inst_nm+' '+args.join(',');
				
				instr.appendChild(document.createElement('br'));
				instr.appendChild(document.createElement('br'));

				let registers=document.createElement('SECTION');
				for(let x=0, len_x=curr.r_reg_nm.length; x<len_x; x++){
					let r=document.createElement('SECTION');
					r.className='register '+curr.r_reg_nm[x];
					r.innerHTML=curr.r_reg_nm[x]+': '+curr.r_reg[x]+' ['+getBarSepStr(curr.r_reg_interp[x],0,0)+']';
					r.title='hex [1 byte int | 2 byte int | 4 byte int | 8 byte int | string]';
					registers.appendChild(r);
				}				
					registers.appendChild(document.createElement('br'));
				
				for(let x=0, len_x=curr.x_reg_nm.length; x<len_x; x++){
					let r=document.createElement('SECTION');
					r.className='register '+curr.x_reg_nm[x];
					r.innerHTML=curr.x_reg_nm[x]+': '+curr.x_reg[x]+' ['+getBarSepStr(curr.x_reg_interp[x][0],0,7)+' || '+getBarSepStr(curr.x_reg_interp[x][1],0,15)+']';
					r.title='hex [float | float | float | float || double | double]';
					registers.appendChild(r);
				}
					registers.appendChild(document.createElement('hr'));
				
				instr.appendChild(registers);

			/*	let stack=document.createElement('SECTION');
				for(let x=0, len_x=curr.stack.length; x<len_x; x++){
					let r=document.createElement('SECTION');	
					r.className='stack';
					r.setAttribute=('index',x);
					r.innerHTML=curr.stack[x];
					stack.appendChild(r);
				}				
					stack.appendChild(document.createElement('br'));

			instr.appendChild(stack);*/
			
			inst_HTML.appendChild(instr);
			inst_HTML.appendChild(document.createElement('br'));
		}
		
}

}

 document.getElementById("openFile1").addEventListener('change',  function () {
	let fr = new FileReader();
	 fr.onload = function () {
		let arrayBuffer = this.result;
		let byteInts = new Uint8Array(arrayBuffer);
		hexProc(byteInts);
	}
	fr.readAsArrayBuffer(this.files[0]);
}); 
 </script>
</body>
</html>