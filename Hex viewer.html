<html>

<head>
<meta charset="UTF-8">
	<style>
		#rgba_sel select {
			margin-right: 0.27ch;
		}
		body {
			background-color: hsl(0 0% 8% / 1);
			color: white;
		}
		input[type="checkbox"] {
			background: buttonface;
			margin-bottom: 2px;
			margin-left: 3px;
			vertical-align: bottom;
			margin-right: 0.2ch;
		}
		#hex span, #hex2 span {
			margin: 0.115ch 0.115ch 0.123ch 0.1285ch;
			white-space: nowrap;
			border-width: 1px;
			border-color: rgb(128 128 128);
			border-style: dotted;
			text-align: center;
			place-self: center;
			height: max-content;
			padding: 0.24ch 0.24ch 0.24ch 0.24ch;
		}
		#hex span.isHovered, #hex2 span.isHovered {
			background-color:hsl(129deg 55% 16%);
			border-color: hsl(129deg 100% 50%);
			border-style: dashed !important; 
			border-width: 4px !important;
		}		
		#hex2 span.rgb{
			transform: skewX(-5deg);
			border-style: solid;
			border-width:1px;
			text-decoration-skip-ink: none;
		}
		#hex span.rgb.isHovered, #hex2 span.rgb.isHovered {
			border-color: hsl(180deg 100% 50%) !important;
			border-style: groove !important; 
			border-width: 10px !important;
			zoom: 139%;
		}
		#hex2 span.foi {
			color: hsl(178deg 100% 50%);
			font-weight: bold;
		}
	</style>	
	<style id="doc_CSS2"></style>
</head>

<body>
	<title>Hex viewer</title>
	<h1 id="ttl" style="margin: 0px; padding: 0px 0px 8px 0px; text-align: center;">Hex viewer</h1>
					<div contenteditable="true" id="n_count_div" style="display: none; border: #7f7f7f 1px outset; padding-left: 0.73ch; padding-right: 0.73ch; zoom: 81.5%; border-style: dotted;">4</div>
			<select  id="type_view" style="width: max-content;">
				<optgroup label="Char (Unicode)">
					<option id="nbc">n byte char</option>
					<option id="spc">4 byte surrogate pair char</option>
				</optgroup>
				<optgroup label="Int">
					<option id="nbyus">n byte int (unsigned, signed)</option>
					<option id="nbys">n byte signed int</option>
					<option id="nbyu">n byte unsigned int</option>
					<option id="nbus">n bit int (unsigned, signed)</option>
					<option id="nbs">n bit signed int</option>
					<option id="nbu">n bit unsigned int</option>
				</optgroup>
				<optgroup label="Floating point">
					<option id="flt">Float</option>
					<option id="dbl">Double</option>
				</optgroup>
				<option id="col">RGB(A) byte hex</option>
				<option id="bin">Binary</option>
			</select>
		<section id="rgba_sel" style="display: none;">
			<select  id="rgba_sel1" style="width: max-content;">
				<option>R</option>
				<option>A</option>
				<option>G</option>
				<option>B</option>
			</select>
			<select  id="rgba_sel2" style="width: max-content;">
				<option>G</option>
				<option>B</option>
				<option>R</option>
				<option>A</option>
			</select>
			<select  id="rgba_sel3" style="width: max-content;">
				<option>B</option>
				<option>R</option>
				<option>G</option>
				<option>A</option>
			</select>
			<select  id="rgba_sel4" style="width: max-content;">
				<option></option>
				<option>A</option>
				<option>B</option>
				<option>R</option>
				<option>G</option>
			</select>
		</section>
			<section id='be_box' style="display: contents; visibility: visible;	">
				<input type="checkbox" id="big_end"></input>
				<label for="big_end">Big endian</label>
			</section>
		<button id="conv" style="margin-left: 0.16ch;">Convert hex</button>
		<section id="hex_scts"  style="display: inline-flex; flex-flow: row nowrap; place-content: flex-start;max-width: 100%;width: 100%; overflow-y: hidden;">
		<section id="hex_sct"  style="display: inline-flex; flex-flow: column nowrap; place-content: flex-start;max-width: 50%;width: 50%;">
			<div contenteditable id="hex" style="height: max-content;min-height: 92%;display: inline-flex;border: 2px solid #886a0773;flex-flow: wrap;place-content: flex-start;min-height: 86.549vh;margin-top: 0.451%;"></div>
	</section>
	<section id="hex_sct2"  style="display: inline-flex; flex-flow: column nowrap; place-content: flex-start;max-width: 50%;width: 50%;min-height: 92%;">
			<div id="hex2" style="min-height: 92%;display: inline-flex;border: 0;flex-flow: wrap;place-content: flex-start;min-height: 87vh;padding-left: 0.111em;"></div>
	</section>
	<section id="offset_info" title="Hovered offset" style="width: min-content;height: min-content;border:2px outset rgb(113 0 255);text-align: center;white-space: pre-wrap;margin-left: 0.07%;">Offset: </section>
</section>

<script>

function reverse_string(s) {
  let o = '';
  for (let i=s.length - 1; i >= 0; i--){
		o += s[i];
	}
  return o;
}

const lookup_hex_bin={
												'0': '0000',
												'1': '0001',
												'2': '0010',
												'3': '0011',
												'4': '0100',
												'5': '0101',
												'6': '0110',
												'7': '0111',
												'8': '1000',
												'9': '1001',
												'A': '1010',
												'B': '1011',
												'C': '1100',
												'D': '1101',
												'E': '1110',
												'F': '1111'
};

const lookup_hex={
										'00':0,
										'01':1,
										'02':2,
										'03':3,
										'04':4,
										'05':5,
										'06':6,
										'07':7,
										'08':8,
										'09':9,
										'0A':10,
										'0B':11,
										'0C':12,
										'0D':13,
										'0E':14,
										'0F':15,
										'10':16,
										'11':17,
										'12':18,
										'13':19,
										'14':20,
										'15':21,
										'16':22,
										'17':23,
										'18':24,
										'19':25,
										'1A':26,
										'1B':27,
										'1C':28,
										'1D':29,
										'1E':30,
										'1F':31,
										'20':32,
										'21':33,
										'22':34,
										'23':35,
										'24':36,
										'25':37,
										'26':38,
										'27':39,
										'28':40,
										'29':41,
										'2A':42,
										'2B':43,
										'2C':44,
										'2D':45,
										'2E':46,
										'2F':47,
										'30':48,
										'31':49,
										'32':50,
										'33':51,
										'34':52,
										'35':53,
										'36':54,
										'37':55,
										'38':56,
										'39':57,
										'3A':58,
										'3B':59,
										'3C':60,
										'3D':61,
										'3E':62,
										'3F':63,
										'40':64,
										'41':65,
										'42':66,
										'43':67,
										'44':68,
										'45':69,
										'46':70,
										'47':71,
										'48':72,
										'49':73,
										'4A':74,
										'4B':75,
										'4C':76,
										'4D':77,
										'4E':78,
										'4F':79,
										'50':80,
										'51':81,
										'52':82,
										'53':83,
										'54':84,
										'55':85,
										'56':86,
										'57':87,
										'58':88,
										'59':89,
										'5A':90,
										'5B':91,
										'5C':92,
										'5D':93,
										'5E':94,
										'5F':95,
										'60':96,
										'61':97,
										'62':98,
										'63':99,
										'64':100,
										'65':101,
										'66':102,
										'67':103,
										'68':104,
										'69':105,
										'6A':106,
										'6B':107,
										'6C':108,
										'6D':109,
										'6E':110,
										'6F':111,
										'70':112,
										'71':113,
										'72':114,
										'73':115,
										'74':116,
										'75':117,
										'76':118,
										'77':119,
										'78':120,
										'79':121,
										'7A':122,
										'7B':123,
										'7C':124,
										'7D':125,
										'7E':126,
										'7F':127,
										'80':128,
										'81':129,
										'82':130,
										'83':131,
										'84':132,
										'85':133,
										'86':134,
										'87':135,
										'88':136,
										'89':137,
										'8A':138,
										'8B':139,
										'8C':140,
										'8D':141,
										'8E':142,
										'8F':143,
										'90':144,
										'91':145,
										'92':146,
										'93':147,
										'94':148,
										'95':149,
										'96':150,
										'97':151,
										'98':152,
										'99':153,
										'9A':154,
										'9B':155,
										'9C':156,
										'9D':157,
										'9E':158,
										'9F':159,
										'A0':160,
										'A1':161,
										'A2':162,
										'A3':163,
										'A4':164,
										'A5':165,
										'A6':166,
										'A7':167,
										'A8':168,
										'A9':169,
										'AA':170,
										'AB':171,
										'AC':172,
										'AD':173,
										'AE':174,
										'AF':175,
										'B0':176,
										'B1':177,
										'B2':178,
										'B3':179,
										'B4':180,
										'B5':181,
										'B6':182,
										'B7':183,
										'B8':184,
										'B9':185,
										'BA':186,
										'BB':187,
										'BC':188,
										'BD':189,
										'BE':190,
										'BF':191,
										'C0':192,
										'C1':193,
										'C2':194,
										'C3':195,
										'C4':196,
										'C5':197,
										'C6':198,
										'C7':199,
										'C8':200,
										'C9':201,
										'CA':202,
										'CB':203,
										'CC':204,
										'CD':205,
										'CE':206,
										'CF':207,
										'D0':208,
										'D1':209,
										'D2':210,
										'D3':211,
										'D4':212,
										'D5':213,
										'D6':214,
										'D7':215,
										'D8':216,
										'D9':217,
										'DA':218,
										'DB':219,
										'DC':220,
										'DD':221,
										'DE':222,
										'DF':223,
										'E0':224,
										'E1':225,
										'E2':226,
										'E3':227,
										'E4':228,
										'E5':229,
										'E6':230,
										'E7':231,
										'E8':232,
										'E9':233,
										'EA':234,
										'EB':235,
										'EC':236,
										'ED':237,
										'EE':238,
										'EF':239,
										'F0':240,
										'F1':241,
										'F2':242,
										'F3':243,
										'F4':244,
										'F5':245,
										'F6':246,
										'F7':247,
										'F8':248,
										'F9':249,
										'FA':250,
										'FB':251,
										'FC':252,
										'FD':253,
										'FE':254,
										'FF':255
									};

function selDivEditable(el){
	try{
			let range = document.createRange();
			let sel = window.getSelection();
			let sp=[...el.childNodes];
			let spe=(sp.length>0)?sp.at(-1):el;
		  let spc=Math.max(spe?.nodeValue?.length || 1,1);
		  el.focus();
		   range.setStart(spe,spc);
			range.collapse(true);
			
			sel.removeAllRanges();
			sel.addRange(range);
	}catch(e){;}
}

function n_byte_unit8_to_int(a,u_only){
			let us=Number("0x"+a.join(''));
			let out={s: us, u:us};

		if(u_only===true){
			return out;
		}else{
			let mx=2;
			for(let i=0, len=(a.length*8)-1; i<len; i++){
				mx*=2;
			}
			mx-=1;
			
			let h=Math.floor(mx/2);
			
			if(out.u>h){
				out.s=-mx+out.u-1;
			}else{
				out.s=out.u;
			}
			
			return out;
		}
}

function n_bit_to_int(a, u_only){
			let us=Number("0b"+a.join(''));
			let out={s: us, u:us};

		if(u_only===true){
			return out;
		}else{
			let n=a.length;
			let mxs='1'.repeat(n);
            let mx=Number("0b"+mxs);
			
			let h=Math.floor(mx/2);
			
			if(out.u>h){
				out.s=-mx+out.u-1;
			}else{
				out.s=out.u;
			}
			
			return out;
		}
}

 function getNoDigits(n){
		return Math.max(1, Math.floor(Math.log10(Math.abs(n))+1) );
}

function absBoundingClientRect(el){
	let st = [window?.scrollY,
					window?.pageYOffset,
					el?.ownerDocument?.documentElement?.scrollTop,
					document?.documentElement?.scrollTop,
					document?.body?.parentNode?.scrollTop,
					document?.body?.scrollTop,
					document?.head?.scrollTop];
					
		let sl = [window?.scrollX,
						window?.pageXOffset,
						el?.ownerDocument?.documentElement?.scrollLeft,
						document?.documentElement?.scrollLeft,
						document?.body?.parentNode?.scrollLeft,
						document?.body?.scrollLeft,
						document?.head?.scrollLeft];
						
				let scrollTop=0;
				for(let k=0; k<st.length; k++){
					if(!!st[k] && typeof  st[k] !=='undefined' && st[k]>0){
						scrollTop=(st[k]>scrollTop)?st[k]:scrollTop;
					}
				}			

				let scrollLeft=0;
				for(let k=0; k<sl.length; k++){
					if(!!sl[k] && typeof  sl[k] !=='undefined' && sl[k]>0){
						scrollLeft=(sl[k]>scrollLeft)?sl[k]:scrollLeft;
					}
				}
	
	const rct=el.getBoundingClientRect();
	let r={};

	r.left=rct.left+scrollLeft;
	r.right=rct.right+scrollLeft;
	r.top=rct.top+scrollTop;
	r.bottom=rct.bottom+scrollTop;
	r.height=rct.height;
	r.width=rct.width;
	
	return r;
}

var elems={};
var hx_arr=[];
var hx_arr_int=[];
var bits_arr=[];
var hx_arr_offs=[];
var hovSpans=[];
var hovSpans2=[];
var hexSpans=[];
var hexSpans2=[];

var mxh=0;
var mxw=0;

elems.type_view = document.getElementById('type_view');
elems.type_view.selectedIndex=8; //float

var hx_interps={};
var hx_interps_be={};

var bit_interps={};
var bit_interps_be={};
var bit_interps_hex=[];

elems.hex_scts = document.getElementById('hex_scts');
elems.hex_sct = document.getElementById('hex_sct');
elems.hex_sct2 = document.getElementById('hex_sct2');
elems.hex = document.getElementById('hex');
elems.hex2 = document.getElementById('hex2');
elems.big_end = document.getElementById('big_end');
elems.be_box = document.getElementById('be_box');
elems.doc_CSS2 = document.getElementById('doc_CSS2');
elems.ttl = document.getElementById('ttl');
elems.offset_info = document.getElementById('offset_info');
elems.conv = document.getElementById('conv');
elems.rgba_sel=document.getElementById('rgba_sel');
elems.n_count_div=document.getElementById('n_count_div');
elems.n_count_div.title='Scroll over or type value (n bit/byte) here!';

function copy_hdl(event){
  let selectedText = window.getSelection().toString(); 
  selectedText = selectedText.split('\n').join(' ');

  clipboardData = event.clipboardData || window.clipboardData || event.originalEvent.clipboardData;
  clipboardData.setData('text/plain', selectedText);

  event.preventDefault();
}

elems.hex.addEventListener("copy", (event) => { copy_hdl(event); });
elems.hex2.addEventListener("copy", (event) => { copy_hdl(event); });

allLoadedSpans=false;
var hexBoxRect=absBoundingClientRect(elems.hex);

function doRsz(){
	elems.hex.style.transform=`translateY(0px)`;
	hexBoxRect=absBoundingClientRect(elems.hex);
}

elems.hex_scts = document.getElementById('hex_scts');

elems.hex.addEventListener('pointerleave',(event)=>{
	elems.hex.style.transform=`translateY(0px)`;
});

elems.hex2.addEventListener('pointerleave',(event)=>{
	elems.hex2.style.transform=`translateY(0px)`;
});

window.addEventListener('resize',(event)=>{
	doRsz();
});

window.onscroll=(e)=>{
	elems.offset_info.style.transform=`translateY(${Math.max(0,window.scrollY-absBoundingClientRect(elems.hex_scts).top+5)}px)`;
}

function p_enter(event,n){
	if(allLoadedSpans){
		let t=event.target;
		for(let i=0, len=hovSpans.length; i<len; i++){
			hovSpans[i].classList.remove('isHovered');
		}
		for(let i=0, len=hovSpans2.length; i<len; i++){
			hovSpans2[i].classList.remove('isHovered');
		}
			let ix=parseInt(t.getAttribute('ix'));
			t.classList.add('isHovered');
			elems.offset_info.innerHTML='Offset: '+t.title;
		if(n===1){
			hovSpans=[t];
			let t2=hexSpans2[ix];
			if(bit_interps_hex.length===0){
				t2.classList.add('isHovered');
				elems.offset_info.innerHTML='Offset: '+t2.title;
				hovSpans2=[t2];
			}else{
					let bi=bit_interps_hex[ix];
					for(let k=0, len_k=bi.length; k<len_k; ++k){
						let bik=bi[k];
						let s=hexSpans2[bik]
						s.classList.add('isHovered');
						hovSpans2.push(s);
					}
			}
			let r2=absBoundingClientRect(hovSpans2[0]);
			let r=absBoundingClientRect(t);
			let r20=absBoundingClientRect(hexSpans2[0]);
			if((hexBoxRect.top+(r2.top-r20.top))>document.body.clientHeight){
				let tx=r.top-r2.top-(hexBoxRect.top-r20.top);
				elems.hex2.style.transform=`translateY(${tx}px)`;
			}else{
				elems.hex2.style.transform=`translateY(0px)`;
			}
		}else{
			hovSpans2=[t];
			hovSpans=[];
			
			let len=parseInt(t.getAttribute('byte_len'));
			let n=Math.min(hexSpans.length,ix+len)-1;
			for(let i=ix, len=n; i<=len; i++){
				let s=hexSpans[i];
				s.classList.add('isHovered');
				hovSpans.push(s);
			}

			let r=absBoundingClientRect(hexSpans[ix]); //first hovered span of hex div
			let r2=absBoundingClientRect(t);
			let r0=absBoundingClientRect(hexSpans[0]);
			let r20=absBoundingClientRect(hexSpans2[0]);
			let txb=-r.top-hexBoxRect.top+r0.top;
			let tx=r2.top+txb; //put both hovered spans at same level
			let tx0=Math.max(window.scrollY-hexBoxRect.top,0); //Place first byte at top
			
					if(r.top-r0.top > document.body.clientHeight){
						elems.hex.style.transform=`translateY(${tx}px)`;
					}else{
						elems.hex.style.transform=`translateY(${tx0}px)`;
				}
		}
	}
}

function p_enter_bits(event,fr,to){
	if(allLoadedSpans){
		let t=event.target;
		for(let i=0, len=hovSpans.length; i<len; i++){
			hovSpans[i].classList.remove('isHovered');
		}
		for(let i=0, len=hovSpans2.length; i<len; i++){
			hovSpans2[i].classList.remove('isHovered');
		}
			t.classList.add('isHovered');
			elems.offset_info.innerHTML='Offset: '+hexSpans[fr].title;
			hovSpans2=[t];
			hovSpans=[];

			for(let i=fr; i<=to; ++i){
				let s=hexSpans[i]
				s.classList.add('isHovered');
				hovSpans.push(s);
			}
			
			let r=absBoundingClientRect(hexSpans[fr]); //first hovered span of hex div
			let r2=absBoundingClientRect(t);
			let r0=absBoundingClientRect(hexSpans[0]);
			let r20=absBoundingClientRect(hexSpans2[0]);
			let txb=-r.top-hexBoxRect.top+r0.top;
			let tx=r2.top+txb; //put both hovered spans at same level
			let tx0=Math.max(window.scrollY-hexBoxRect.top,0); //Place first byte at top
			
					if(r.top-r0.top > document.body.clientHeight){
						elems.hex.style.transform=`translateY(${tx}px)`;
					}else{
						elems.hex.style.transform=`translateY(${tx0}px)`;
				}
	}
}

function p_leave(){
	if(allLoadedSpans){
		for(let i=0, len=hovSpans.length; i<len; i++){
			hovSpans[i].classList.remove('isHovered');
		}
		for(let i=0, len=hovSpans2.length; i<len; i++){
			hovSpans2[i].classList.remove('isHovered');
		}
		elems.offset_info.innerHTML='Offset: ';
		hovSpans=[];
		hovSpans2=[];
	}
}

function get_subarray(arr,f,t,rvrs){
	let out=[];
	for(i=f; i<=t; ++i){
		if(rvrs===true){
			out.push(arr[i]);
		}else{
			out.unshift(arr[i]);
		}
	}
	return out;
}

async function get_interps_bit(i, tp_id, be, bit_interps_curr, n, ns){
	return new Promise(function(resolve) {
		let df=bits_arr.length-i;
			if(df>=n){
				let rhx=[];
				let to_bit=i+n-1;
				let to_byte=Math.floor(i/8);
				let to_byte2=Math.floor(to_bit/8);
				if(!be){
					rhx=get_subarray(bits_arr,i,to_bit);
				}else{
					rhx=get_subarray(bits_arr,i,to_bit,true);
				}
				let rhxb=rhx.map((b)=>{return b.bit;});
				let b=n_bit_to_int(rhxb);
				let p=(b.u===b.s)?b.u:`(${b.u}, ${b.s})`;
				let bs=rhxb.join('');
				bit_interps_curr['nbus__'+ns].push([p,to_byte,to_byte2,bs]);
				bit_interps_curr['nbs__'+ns].push([b.s,to_byte,to_byte2,bs]);
				bit_interps_curr['nbu__'+ns].push([b.u,to_byte,to_byte2,bs]);
			}else{
				try{
					let tp_names=['nbus__'+ns,'nbs__'+ns,'nbu__'+ns];
					for(let k=0; k<3; ++k){
						let tp_name=tp_names[k];
						if(typeof bit_interps_curr[tp_name]==='undefined'){
							bit_interps_curr[tp_name]=[null];
						}else{
							bit_interps_curr[tp_name].push(null);
						}
					}
				}catch(e){;}
			}
		resolve();
	});
}

async function get_interps_byte(i, tp_id, be, hx_interps_curr, n, tp_name){
	return new Promise(function(resolve) {
		if(tp_id==='nbc'){ // n byte char
				let df=hx_arr_int.length-i;
				if(df>=n){		   
					let rhx=[];
					if(!be){
						rhx=get_subarray(hx_arr,i,i+n-1);
					}else{
						rhx=get_subarray(hx_arr,i,i+n-1,true);
					}
					let b=n_byte_unit8_to_int(rhx);
					hx_interps_curr[tp_name].push([String.fromCharCode(b.u),n]);
				}else{
					if(typeof hx_interps_curr[tp_name]==='undefined'){
						hx_interps_curr[tp_name]=[null];
					}else{
						hx_interps_curr[tp_name].push(null);
					}
				}
		}else if(tp_id==='spc'){
			let df=hx_arr_int.length-i;
			if(df>=4){
				let rhx=(be)?[hx_arr[i]+hx_arr[i+1], hx_arr[i+2]+hx_arr[i+3]]:[hx_arr[i+1]+hx_arr[i], hx_arr[i+3]+hx_arr[i+2]];
				let codePoint =rhx.reduce((acc, cur) => {
					cur = parseInt(cur, 16); return acc += cur<0xDC00 ? (cur-0xD7F7)<<10 : cur; //https://stackoverflow.com/posts/53882179/revisions | Mr Lister
				}, 0);
				try{
					hx_interps_curr[tp_name].push([String.fromCodePoint(codePoint),4]);
				}catch(e){
					if(typeof hx_interps_curr[tp_name]==='undefined'){
						hx_interps_curr[tp_name]=[null];
					}else{
						hx_interps_curr[tp_name].push(null);
					}
				}
			}else{
				if(typeof hx_interps_curr[tp_name]==='undefined'){
					hx_interps_curr[tp_name]=[null];
				}else{
					hx_interps_curr[tp_name].push(null);
				}
			}
		}else if(tp_id==='nbyus' || tp_id==='nbys' || tp_id==='nbyu'){ // n-byte (un)signed)
			let df=hx_arr_int.length-i;
			let ns=n.toString();
			if(df>=n){
				let rhx=[];
				if(!be){
					rhx=get_subarray(hx_arr,i,i+n-1);
				}else{
					rhx=get_subarray(hx_arr,i,i+n-1,true);
				}
				let b=n_byte_unit8_to_int(rhx);
				let p=(b.u===b.s)?b.u:`(${b.u}, ${b.s})`;
				hx_interps_curr['nbyus__'+ns].push([p,n]);
				hx_interps_curr['nbys__'+ns].push([b.s,n]);
				hx_interps_curr['nbyu__'+ns].push([b.u,n]);
			}else{
					let tp_names=['nbyus__'+ns,'nbys__'+ns,'nbyu__'+ns];
					for(let k=0; k<3; ++k){
						let tp_name=tp_names[k];
						if(typeof hx_interps_curr[tp_name]==='undefined'){
							hx_interps_curr[tp_name]=[null];
						}else{
							hx_interps_curr[tp_name].push(null);
						}
					}
			}
		}else if(tp_id==='flt'){ //float
				let df=hx_arr_int.length-i;
				if(df>=4){
					let rhx=[];
					if(!be){
						rhx=get_subarray(hx_arr_int,i,i+3);
					}else{
						rhx=get_subarray(hx_arr_int,i,i+3,true);
					}
					let data = rhx;
					let view = new DataView(new Uint8Array(data).buffer);
					let f=view.getFloat32(0); //to be rounded
					if( isNaN(f) ){
						if(typeof hx_interps_curr[tp_name]==='undefined'){
							hx_interps_curr[tp_name]=[null];
						}else{
							hx_interps_curr[tp_name].push(null);
						}
					}else{
						let x=7;
						let opts={useGrouping: false, minimumFractionDigits: 0, maximumFractionDigits: x};
						let d=getNoDigits(f);
						let lb=Math.pow(10,-x);
						let lb2=lb-lb/2;
						if(d>=x || (d<lb2 && d>0) || (d>-lb2 && d<0) ){
							hx_interps_curr[tp_name].push( [f.toExponential(x),4] );
						}else{
							opts.maximumFractionDigits=Math.max(0, x+1-d );
							hx_interps_curr[tp_name].push( [f.toLocaleString('en-GB',opts),4] );
						}
					}
				}else{
					if(typeof hx_interps_curr[tp_name]==='undefined'){
						hx_interps_curr[tp_name]=[null];
					}else{
						hx_interps_curr[tp_name].push(null);
					}
				}
		}else if(tp_id==='dbl'){
			let df=hx_arr_int.length-i;
				if(df>=8){
					let rhx=[];
					if(!be){
						rhx=get_subarray(hx_arr_int,i,i+7);
					}else{
						rhx=get_subarray(hx_arr_int,i,i+7,true);
					}
					let data = rhx;
					let view = new DataView(new Uint8Array(data).buffer);
					let f=view.getFloat64(0); //to be rounded
					if( isNaN(f) ){
						hx_interps_curr[tp_name].push(null);
					}else{
						let x=15;
						let opts={useGrouping: false, minimumFractionDigits: 0, maximumFractionDigits: x};
						let d=getNoDigits(f);
						let lb=Math.pow(10,-x)
						let lb2=lb-lb/2;
						if(d>=x || (d<lb2 && d>0) || (d>-lb2 && d<0) ){
							hx_interps_curr[tp_name].push( [f.toExponential(x),8] );
						}else{
							opts.maximumFractionDigits=Math.max(0, x+1-d );
							hx_interps_curr[tp_name].push( [f.toLocaleString('en-GB',opts), 8] );
						}
					}
				}else{
					if(typeof hx_interps_curr[tp_name]==='undefined'){
						hx_interps_curr[tp_name]=[null];
					}else{
						hx_interps_curr[tp_name].push(null);
					}
				}
		}else if(tp_id==='bin'){ //binary
			let x=hx_arr[i];
			let bx=lookup_hex_bin[x[0]];
			if(x.length>1){
				bx+=lookup_hex_bin[x[1]];
			}
			if(be){
				bx=reverse_string(bx);
			}	
			hx_interps_curr[tp_name].push([bx,1]);
		}else if(tp_id==='col'){ // RGB(A)
				let df=hx_arr_int.length-i;
				let rhxi=[]; // Force RGBA order
				let col_ixs={R: 0, G: 1, B: 2, A:3};
				let col_ixs_arr=[null, null, null, null];
				let chd=elems.rgba_sel.children;
				
				for (let k=0; k<4; k++){
					let ck=chd[k];
					let kix=col_ixs[ck.value];
					if(kix!==null){
						col_ixs_arr[ kix ]=k; // BGR => [2, 1, 0, null]
					}
				}
				
				let n=(chd[3].value==='')?3:4;
				if(df>=n){		   
					let rhx=[];
					if(!be){
						rhx=get_subarray(hx_arr,i,i+n-1);
					}else{
						rhx=get_subarray(hx_arr,i,i+n-1,true);
					}
					
					for (let k=0; k<n; k++){
						let r=[rhx[k]];
						let b=n_byte_unit8_to_int(r);
						let kix=col_ixs_arr[k];
						if(kix!==null){
							rhxi[ kix ]=b.u;
						}
					}
					let rgbx='#'+rhx.join('');
					
					hx_interps_curr[tp_name].push([rgbx,rhxi,col_ixs_arr,n]);
				}else{
					if(typeof hx_interps_curr[tp_name]==='undefined'){
						hx_interps_curr[tp_name]=[null];
					}else{
						hx_interps_curr[tp_name].push(null);
					}
				}
		}
		resolve();
	});
}

async function makeSpans(i){
	return new Promise(function(resolve) {
			if(hx_arr!== null && hx_arr.length>0){
				let hxtm='';
				let hxtm2='';
				let tp=elems.type_view.selectedIndex;
				let tp_id=elems.type_view[tp].id;
				let be=elems.big_end.checked;
				let hx_interps_curr=(be)?hx_interps_be:hx_interps;
				let nt=elems.n_count_div.innerText;
				let tp_name=tp_id+'__'+nt;
				let isFl=(tp_id==='flt'||tp_id==='dbl')?true:false;
				let cc=hx_interps_curr[tp_name][i];
				let x=hx_arr_offs[i];
				let isCol=(tp_id==='col' )?true:false;
				let crgb='';
				let crgb_a='';
				let crgb_3='';
				let crgb_bg='';
				let ccn=(cc===null || typeof cc==='undefined')?true:false;
				let p=(ccn)?'':cc[0];
				let n=(ccn)?'':cc[1];
				if(isCol && cc!==null){
					p=cc[0];
					c=cc[1];
					let aud=(c[3]===null || typeof c[3]==='undefined')?true:false;
					crgb_txt=(aud)?`rgb(${c[0]},${c[1]},${c[2]})`:`rgba(${c[0]},${c[1]},${c[2]},${c[3]})`;
					crgb=(aud)?`rgb(${c[0]},${c[1]},${c[2]})`:`rgba(${c[0]},${c[1]},${c[2]},${c[3]})`;
					crgb_a=`rgba(${c[0]},${c[1]},${c[2]},0.31)`;
					crgb_3=`rgb(${c[0]},${c[1]},${c[2]})`;
					crgb_bg=(aud)?crgb_a:crgb;
					let c2=cc[2];
					p+=(aud)?` (${c[ c2[0] ]},${c[ c2[1] ]},${c[ c2[2] ]})`:` (${c[ c2[0] ]},${c[ c2[1] ]},${c[ c2[2] ]},${c[ c2[3] ]})`;
					n=cc[3];
				}
				elems.hex2.innerHTML+='<span onpointerenter="p_enter(event,2);"  byte_len="'+n+'"' +( (isFl && !p.includes('e') && p!=='0' && p!=='-0' )?' class="foi" ':'')+( (isCol && crgb!=='')?`class="rgb" style="background:${crgb_bg} ;border-color: ${crgb_3}; text-decoration: ${crgb} 3px underline;" `:'')+'onpointerleave="p_leave();" title="'+x+'" ix="'+i+'">'+p+'</span>';
		}else{
			elems.hex2.innerHTML='';
		}
		resolve();
	});
}

async function makeSpansBits(i, tp_id, be, bit_interps_curr, n, ns,tp_name){
	return new Promise(function(resolve) {
			if(bits_arr!== null && bits_arr.length>0){
				let hxtm='';
				let hxtm2='';
				let be=elems.big_end.checked;
				let bit_interps_curr=(be)?bit_interps_be:bit_interps;
				let c=bit_interps_curr[tp_name][i];
				if(c===null){
					elems.hex2.innerHTML+='<span></span>';
				}else{
					let checkSame=(c[0].toString()===c[3])?c[0]:`${c[0]} (${c[3]})`
					elems.hex2.innerHTML+='<span onpointerenter="p_enter_bits(event,'+c[1]+','+c[2]+');" onpointerleave="p_leave();">'+checkSame+'</span>';
					for(let k=c[1]; k<=c[2]; ++k){
						if(typeof bit_interps_hex[k]==='undefined'){
							bit_interps_hex[k]=[i]
						}else{
							bit_interps_hex[k].push(i);
						}
					}
				}
			}else{
				elems.hex2.innerHTML='';
			}
		resolve();
	});
}

function makeSpansBytes(){
		let hxtm='';
		hx_arr_offs=[];
	for(let i=0, len=hx_arr.length; i<len; i++){
		let ih=hx_arr[i];
		let x=(i>9)?('+'+i+' {+'+(i.toString(16).toLocaleUpperCase() )+'}'):('+'+i);
		hx_arr_offs.push(x);
			hxtm+='<span onpointerenter="p_enter(event,1);" onpointerleave="p_leave();"  title="'+x+'" ix="'+i+'">'+ih+' </span>';
	}
	
	elems.hex.innerHTML=hxtm;
	//elems.hex.style.height = 'inherit';
	//elems.hex.style.height = (elems.hex.scrollHeight+4)+"px";
	hexSpans=[...elems.hex.getElementsByTagName('SPAN')];	
	
	for(let i=0, len=hexSpans.length; i<len; i++){
		let h=hexSpans[i].clientHeight;
		let w=hexSpans[i].clientWidth;
		mxh=(h>mxh)?h:mxh;
		mxw=(w>mxw)?h:mxw;
	}
	elems.doc_CSS2.innerHTML=`#hex2 span{min-height: ${mxh}px !important; height: fit-content !important; min-width: ${mxw}px !important; width: fit-content !important;} #hex span{min-width: ${mxw}px !important; width: fit-content !important;}`;
}

async function interp_span_bits(t){
	return new Promise(function(resolve) {
		let tp=elems.type_view.selectedIndex;
		let tp_id=elems.type_view[tp].id;
		let be=elems.big_end.checked;
		let bit_interps_curr=(be)?bit_interps_be:bit_interps;
		let nt=elems.n_count_div.innerText;
		let n=parseInt(nt);
		let tp_name=tp_id+'__'+nt;
		bit_interps_curr['nbus__'+nt]=[];
		bit_interps_curr['nbs__'+nt]=[];
		bit_interps_curr['nbu__'+nt]=[];
		
				for(let i=0, len=bits_arr.length; i<len; i++){
					setTimeout( 
												(async ()=>{
														await get_interps_bit(i, tp_id, be, bit_interps_curr, n,nt);
														await makeSpansBits(i, tp_id, be, bit_interps_curr, n,nt, tp_name);
														if(i===len-1){
															elems.ttl.innerText="Hex viewer";
															allLoadedSpans=true;
															elems.hex2.style.height = 'inherit';
															elems.hex2.style.height = (elems.hex2.scrollHeight+4)+"px";
															hexSpans2=[...elems.hex2.getElementsByTagName('SPAN')];																	
															selDivEditable(t);
															resolve();
														}else{
															elems.ttl.innerText="Hex viewer - Loaded: "+(i+1)+"/"+len;
														}
												}),
											0);
			}
		});
}

async function interp_span(t){
	return new Promise(function(resolve) {
		let tp=elems.type_view.selectedIndex;
		let tp_id=elems.type_view[tp].id;
		let be=elems.big_end.checked;
		let hx_interps_curr=(be)?hx_interps_be:hx_interps;
		let nt=elems.n_count_div.innerText;
		let n=parseInt(nt);
		let tp_name=tp_id+'__'+nt;
		
		if(tp_id==='nbyus' || tp_id==='nbys' || tp_id==='nbyu'){ // n-byte (un)signed)
				hx_interps_curr['nbyus__'+nt]=[];
				hx_interps_curr['nbys__'+nt]=[];
				hx_interps_curr['nbyu__'+nt]=[];
		}else{
			hx_interps_curr[tp_name]=[];
		}
				for(let i=0, len=hx_arr.length; i<len; i++){
					setTimeout( 
												(async ()=>{
														await get_interps_byte(i, tp_id, be, hx_interps_curr, n, tp_name);
														await makeSpans(i);
														if(i===len-1){
															elems.ttl.innerText="Hex viewer";
															allLoadedSpans=true;
															elems.hex2.style.height = 'inherit';
															elems.hex2.style.height = (elems.hex2.scrollHeight+4)+"px";
															hexSpans2=[...elems.hex2.getElementsByTagName('SPAN')];																	
															selDivEditable(t);
															resolve();
														}else{
															elems.ttl.innerText="Hex viewer - Loaded: "+(i+1)+"/"+len;
														}
												}),
											0);
			}
		});
}

async function interp_span2_bits(){
	return new Promise(function(resolve) {
				let tp=elems.type_view.selectedIndex;
				let tp_id=elems.type_view[tp].id;
				let be=elems.big_end.checked;
				let bit_interps_curr=(be)?bit_interps_be:bit_interps;
				let nt=elems.n_count_div.innerText;
				let n=parseInt(nt);
				let tp_name=tp_id+'__'+nt;		
				let empty_interp=(typeof bit_interps_curr[tp_name]==='undefined')?true:false;
				for(let i=0, len=bits_arr.length; i<len; i++){
				setTimeout( 
											(async ()=>{
												if(empty_interp){
													await get_interps_bit(i, tp_id, be, bit_interps_curr, n, tp_name);
												}else{
													bit_interps_curr[tp_name]=[];
												}
												makeSpans(i);
												if(i===len-1){
													hexSpans2=[...elems.hex2.getElementsByTagName('SPAN')];
													elems.ttl.innerText="Hex viewer";
													allLoadedSpans=true;
													resolve();
												}else{
													elems.ttl.innerText="Hex viewer - Loaded: "+(i+1)+"/"+len;
												}
											}),
										0);
		}	
	});
}

async function interp_span2(){
	return new Promise(function(resolve) {
				let tp=elems.type_view.selectedIndex;
				let tp_id=elems.type_view[tp].id;
				let be=elems.big_end.checked;
				let hx_interps_curr=(be)?hx_interps_be:hx_interps;
				let nt=elems.n_count_div.innerText;
				let n=parseInt(nt);
				let tp_name=tp_id+'__'+nt;		
				let empty_interp=(typeof hx_interps_curr[tp_name]==='undefined')?true:false;
				for(let i=0, len=hx_arr.length; i<len; i++){
				setTimeout( 
											(async ()=>{
												if(empty_interp){
													await get_interps_byte(i, tp_id, be, hx_interps_curr, n, tp_name);
												}else{
													hx_interps_curr[tp_name]=[];
												}
												makeSpans(i);
												if(i===len-1){
													hexSpans2=[...elems.hex2.getElementsByTagName('SPAN')];
													elems.ttl.innerText="Hex viewer";
													allLoadedSpans=true;
													resolve();
												}else{
													elems.ttl.innerText="Hex viewer - Loaded: "+(i+1)+"/"+len;
												}
											}),
										0);
		}	
	});
}

elems.conv.onclick=(event)=>{
  elems.hex2.innerHTML='';
  elems.offset_info.innerHTML='Offset: ';
	let t=elems.hex;
	allLoadedSpans=false;
	let hx_arr_chk=t.innerText.toLocaleUpperCase().split(/\s+/).join('').match(/([0-9]|[A-F]){1,2}/g);
	if(hx_arr_chk !==null && typeof hx_arr_chk!=='undefined' && hx_arr_chk.length>0){
		hx_arr=hx_arr_chk;
		hx_arr_int=hx_arr.map((x)=>{return lookup_hex[x]});
		let tp=elems.type_view.selectedIndex;
		let tp_id=elems.type_view[tp].id;
		let isBit=(tp_id==='nbus' || tp_id==='nbs' || tp_id==='nbu')?true:false;
		if(isBit){
			bits_arr=[];
			for (let i=0, len=hx_arr.length; i<len; ++i){
				let x=hx_arr[i];
				let bx=lookup_hex_bin[x[0]];
				if(x.length>1){
					bx+=lookup_hex_bin[x[1]];
				}
				for (let k=0, len_k=bx.length; k<len_k; ++k){
					bits_arr.push({bit: parseInt(bx[k]), byte_hex: x, byte_ix: i });
				}
			}
		}
		makeSpansBytes();
		hx_interps={};
		hx_interps_be={};
		bit_interps={};
		bit_interps_hex=[];
		bit_interps_be={};
		hovSpans=[];
		hovSpans2=[];
		if(isBit){
			( async ()=>{ await interp_span_bits(t); } )();
		}else{
			( async ()=>{ await interp_span(t); } )();
		}
	}else{
		elems.hex2.innerHTML='';
		elems.hex.innerHTML='';
	}
}

function type_change(event){
	let tp=elems.type_view.selectedIndex;
	let tp_id=elems.type_view[tp].id;
	let isBit=(tp_id==='nbus' || tp_id==='nbs' || tp_id==='nbu')?true:false;
	let is_n=( isBit || tp_id==='nbyus' || tp_id==='nbys' || tp_id==='nbyu' || tp_id==='nbc' )?true:false
	if(is_n){
		elems.n_count_div.style.display='-webkit-inline-box';
	}else{
		elems.n_count_div.style.display='none';
	}
	if(tp_id==='col'){
		elems.rgba_sel.style.display='-webkit-inline-box';
	}else{
		elems.rgba_sel.style.display='none';
	}
}

elems.n_count_div.oninput=(event)=>{
	let t=elems.n_count_div;
	let ttx=t.innerText;
	let tni=parseInt(ttx);
	let tn='';
	if(ttx!==''){
		tn=(Number.isNaN(tni))?1:tni;
	}
	t.innerHTML=tn;
}

elems.n_count_div.onwheel=(event)=>{
	let t=elems.n_count_div;
	let tni=parseInt(t.innerText);
	let tn=(Number.isNaN(tni))?4:tni;
	if (event.deltaY < 0){
		t.innerHTML=tn+1;
	}else if (event.deltaY > 0){
		t.innerHTML=(tn<=1)?1:tn-1;
	}
}

elems.hex.oninput=(event)=>{
	let t=elems.hex;
	let sp=t.getElementsByTagName('SPAN');
	if(sp.length>0){
		t.innerHTML=t.innerText;
		selDivEditable(t);
	}
}

elems.type_view.oninput=(event)=>{
	type_change(event);
}

elems.big_end.oninput=(event)=>{
	type_change(event);
}

</script>

</body>

</html>