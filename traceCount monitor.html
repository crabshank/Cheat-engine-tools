 <html>
 <head>
 <style>
div.notes {
	display: inline-block;
    border: #848484;
    border-width: 1px 1px 1px;
    min-width: 10.5ch;
    border-style: outset;
    margin-right: 0.7ch;
	padding: 0.18ch;
}
span.memLink {
    text-decoration: underline;
	cursor: pointer;
    /* color: #167ac6; */
}
 </style>
 </head>
 <body>
 <title>traceCount monitor</title>
 <h1 style="text-align: center;">traceCount monitor</h1>
 <label for="revChk" style="margin-bottom: 0.47ch;display: -webkit-inline-box;">Reverse auto-check direction: <input  type="checkbox"  id="revChk" style="vertical-align: bottom;margin-bottom: 0.2ch;margin-left: 0.2ch;"></input></label><br>
 <label for="openFile1">Load file: </label><input  type="file"  id="openFile1" style="margin-left: 4px;vertical-align: top;"></input>
 <section id="check_info"  style="display: none;width: min-content; height: min-content; border: 2px outset rgb(113, 0, 255); text-align: center; white-space: pre-wrap; position: fixed; right: 5px;"></section>
 <pre id="preTag"></pre>
  <style>
	input[type="checkbox"]{
		filter: hue-rotate(247deg) contrast(1.65) !important;
	}
  </style>
  <script>
  var firstDone=false;
  var isRN=true;
  var chkRev=false;
  var meta_mems=[];
  var mems_chk={};
  const regexp=[/\([^\)]*\[[0-9A-F]+\] \= \{[^\}]+\}[^\)]*\)/g,/\[[0-9A-F]+\] \= \{[^\}]+\}/g,/(\[[0-9A-F]+\]|[0-9A-F]{2})/g];
  const regexp_length=regexp.length;
  const check_info=document.getElementById("check_info");
  const pre_el=document.getElementById('preTag');
  
window.onscroll=(e)=>{
    let tp=(pre_el.getBoundingClientRect().top>0)?'':'5px';
    check_info.style.top=tp;
}
  
  const rvc=document.getElementById("revChk");
  var registers={};
  registers['list_regs']=[
["ST(0)",71],
["ST(1)",72],
["ST(2)",73],
["ST(3)",74],
["ST(4)",75],
["ST(5)",76],
["ST(6)",77],
["ST(7)",78],
["XMM10",{"occs":[]}],
["XMM11",{"occs":[]}],
["XMM12",{"occs":[]}],
["XMM13",{"occs":[]}],
["XMM14",{"occs":[]}],
["XMM15",{"occs":[]}],
["XMM0",{"occs":[]}],
["XMM1",{"occs":[]}],
["XMM2",{"occs":[]}],
["XMM3",{"occs":[]}],
["XMM4",{"occs":[]}],
["XMM5",{"occs":[]}],
["XMM6",{"occs":[]}],
["XMM7",{"occs":[]}],
["XMM8",{"occs":[]}],
["XMM9",{"occs":[]}],
["R10D",56],
["R10W",56],
["R10L",56],
["R10B",56],
["R11D",57],
["R11W",57],
["R11L",57],
["R11B",57],
["R12D",58],
["R12W",58],
["R12L",58],
["R12B",58],
["R13D",59],
["R13W",59],
["R13L",59],
["R13B",59],
["R14D",60],
["R14W",60],
["R14L",60],
["R14B",60],
["R15D",61],
["R15W",61],
["R15L",61],
["R15B",61],
["RAX",{"occs":[]}],
["RBX",{"occs":[]}],
["RCX",{"occs":[]}],
["RDX",{"occs":[]}],
["RDI",{"occs":[]}],
["RSI",{"occs":[]}],
["RBP",{"occs":[]}],
["RSP",{"occs":[]}],
["R10",{"occs":[]}],
["R11",{"occs":[]}],
["R12",{"occs":[]}],
["R13",{"occs":[]}],
["R14",{"occs":[]}],
["R15",{"occs":[]}],
["EAX",48],
["EBX",49],
["ECX",50],
["EDX",51],
["EDI",52],
["ESI",53],
["EBP",54],
["ESP",55],
["RIP",{"occs":[]}],
["EIP",70],
["FP0",{"occs":[]}],
["FP1",{"occs":[]}],
["FP2",{"occs":[]}],
["FP3",{"occs":[]}],
["FP4",{"occs":[]}],
["FP5",{"occs":[]}],
["FP6",{"occs":[]}],
["FP7",{"occs":[]}],
["R8D",92],
["R8W",92],
["R8L",92],
["R8B",92],
["R9D",93],
["R9W",93],
["R9L",93],
["R9B",93],
["SIL",53],
["DIL",52],
["BPL",54],
["SPL",55],
["R8",{"occs":[]}],
["R9",{"occs":[]}],
["AX",48],
["AL",48],
["AH",48],
["BX",49],
["BL",49],
["BH",49],
["CX",50],
["CL",50],
["CH",50],
["DX",51],
["DL",51],
["DH",51],
["SI",53],
["DI",52],
["BP",54],
["SP",55],
["IP",70]
];

let chkCnt=0;
let allChk=[];
let ntes=[];

function insertText(tx,sta,mtc,bfr){

    if(bfr===true){ //insert before
        sta[mtc[1]]=tx+sta[mtc[1]];
    }else{
        let p=mtc[1]+mtc[0].length-1;
        sta[p]+=tx;
    }
    
    return sta;
}

function getLastCheck(){
    let chk=document.querySelectorAll('input[type="checkbox"]:checked');
    let ckl=chk.length;
    let d='none';
    let mx=0;
    if(ckl>0){
        for(let i=0; i<ckl; ++i){
            let ci=chk[i];
            let n=parseInt(ci.getAttribute('ln'));
            mx=(n>mx)?n:mx;
        }
        d='initial';
        check_info.innerHTML=`Last checked line:<br><span title="Click to scroll to" class="memLink" onclick="ntes[${mx}].scrollIntoView();">#${mx+1}</span>`;
    }
    check_info.style.display=d;
}

function do_chkClick_mem(event,isMeta){
    let t=event.target;
    let c=t.checked;
    let m=parseInt(t.getAttribute('meta_mem'));
    let mm=meta_mems[m];
    if(isMeta===true){
        for(let k=1, len_k=mm.length;k<len_k;k++){
                mm[k].checked=c;
                do_chkClick_mem({target: mm[k]});
        }
    }else{
        if(c===false){
            mm[0].checked=false;
        }else{
            let allTrue=true;
            for(let k=1, len_k=mm.length;k<len_k;k++){
                if(mm[k].checked===false){
                    allTrue=false;
                    break;
                }
            }
            mm[0].checked=allTrue;
        }
        let x=parseInt(t.getAttribute('addr_ix'));
        let a=t.getAttribute('address');
        let ar=mems_chk[a];
        if(!chkRev){
            for(let i=x+1, len=ar.length; i<len; i++){
                ar[i].checked=c;
                do_chkClick_mem({target: ar[i]});
            }
        }else{
            for(let i=x-1; i>=0; i--){
                ar[i].checked=c;
                do_chkClick_mem({target: ar[i]});
            }
        }
    }
}

function chkClick_mem(event,isMeta){
    do_chkClick_mem(event,isMeta);
    getLastCheck();
}

function chkClick(event){
	let t=event.target;
	let rg=registers['list_regs'][parseInt(t.getAttribute('reg_ix'))];
	let ocs=rg.at(-1).occs;
	let st=parseInt(t.getAttribute('occ'));
	let oc=allChk[ocs[st]];
	let flg=oc.checked;
	if(!chkRev){
		for(let i=st+1, len=ocs.length; i<len; i++){
			allChk[ocs[i]].checked=flg;
		}
	}else{
		for(let i=st-1; i>=0; i--){
			allChk[ocs[i]].checked=flg;
		}
	}
    getLastCheck();
}

registers['list_regs_len']= registers['list_regs'].length;

	function proc(str){
		//console.log(str);
		let lns=[];
		let rn='';
		if(isRN){
			rn='\r\n';
			lns=str.split(/\r\n\#\d+/);
		}else{
			rn='\n';
			lns=str.split(/\n\#\d+/);
		}
		let lnl=lns.length;
		let lst=lns[lnl-1];
		let mSplt='Memory accesses index:';
		let lstSpl=lst.split(rn+mSplt);
		lns[lnl-1]=`#${lnl}${lstSpl[0]}${rn}`;
		lns[0]+=rn;
		for (let i=1; i<lnl-1; i++){
			lns[i]=`#${i+1}${lns[i]}${rn}`;
		}
		let mems=(mSplt+lstSpl[1]).split(rn);
		let memsL=mems.length;
		for (let i=0; i<memsL; i++){
			lns.push(mems[i]+rn);
		}
		lnl=lns.length;
		let insts=[];
		ntes=[];
		let memAcc=false;
		let c=0;
        
        let mem_ix=0;
        let cm=0;
        
		for (let i=0; i<lnl; i++){
            let inst=lns[i];
			if(memAcc===true){
				let hits=inst.match(/\#\d+/g);
				if(hits!==null){
						let hl=hits.length;
						if(hl>0){
							for (let k=0; k<hl; k++){
								let hk=hits[k];
								inst=inst.split(hk).join(`<span class="memLink" title="Go to ${hk}" onclick="ntes[${hk.split('#')[1]-1}].scrollIntoView();">${hk}</span>`);
							}
							insts.push(inst);
					}
				}
			}else if(lns[i].startsWith('Memory accesses index:')){
				memAcc=true;
				insts.push(lns[i]);
				pre_el.innerHTML=insts.join('');
			}else{
				let empt=(lns[i].trim()==='')?true:false;
				let lnsi_spl =[...lns[i]];
				let out_spl =lnsi_spl;
				let regexp1 = /(?<=\-)[^\t\r]+/g;
				let mtcs_lns = [...lns[i].matchAll(regexp1)];
				let inst_spl2=[];
				if(mtcs_lns.length>0){ //match
					let regexp2 = /\s*[^\s]+\s+/g;
					let mtcs_lns2 = [...mtcs_lns[0][0].matchAll(regexp2)];
					if(mtcs_lns2.length>0){ //match
						let st=mtcs_lns[0].index+mtcs_lns2[0][0].length;
						let ed=mtcs_lns[0].index+mtcs_lns[0][0].length-1;
						let inst_spl=[];
						for (let j=st; j<=ed; j++){
							inst_spl.push(lns[i][j]);
							inst_spl2.push(lns[i][j]);
							out_spl[j]='';
						}
						inst=inst_spl.join('');
						for (let k=0; k<registers['list_regs_len']; k++){
							let ka=k;
							let rk=registers['list_regs'][k];			
							let r=rk[0];
							if(typeof(rk[1])==='number'){
								ka=rk[1];
								rk=registers['list_regs'][ka];
							}
									
							let regexp = new RegExp(r, 'ig');
							let mtcs = [...inst.matchAll(regexp)];
							if(mtcs.length>0){ //match
								for (let m=0, len=mtcs.length; m<len; m++) {
									let mtc=mtcs[m];
									let s=mtc.index;
									let d=s+mtc[0].length-1;
									if(m===0){
										let rk_obj=rk.at(-1);
										let ol=rk_obj.occs.length;
										rk_obj.occs.push(chkCnt);
										inst_spl2[s]=`<input type="checkbox" class="reg_check" reg_ix="${ka}" ln="${c}" title="${r}" occ="${ol}" ovr_occ="${chkCnt}" onclick="chkClick(event);">`+inst_spl[s];
										inst_spl2[d]+='</input>';
										chkCnt++;
									}
									for(let n=s; n<=d; n++){
										inst_spl[n]=' '
									}
									inst=inst_spl.join('');
								}
							}
						}	
						out_spl[st]=inst_spl2.join('');
						inst=out_spl.join('');
						}
               
				}else{
					inst=rn+rn;
				}
				if(!empt){
					inst=`<div contenteditable="true" ln="${c}" title="Notes" class="notes"></div>${inst}`;
                let strs_last=[[inst,0]];
                for(let h=0; h<regexp_length; h++){
                    let mtc=[];
                    let rxh=regexp[h];
                    for(let j=0, len_j=strs_last.length; j<len_j; j++){
                        let sj=strs_last[j];
                        let sj1=sj[1];
                        let mts=[...sj[0].matchAll(rxh)];
                        for(let k=0, len_k=mts.length; k<len_k; k++){
                            let mk=mts[k];
                            mtc.push([mk[0],mk.index+sj1]);
                        }
                        mts=null;
                       sj=null;
                       sj1=null;
                    }
                    strs_last=mtc;
                    mtc=null;
                }
                
                let sta=[...inst];
                let ca=0;
                let adr='';
                let adr_int=adr;
                
                for(let j=0, len_j=strs_last.length; j<len_j; j++){
                    let sj=strs_last[j];
                    let sj0=sj[0];
                    if(sj0.startsWith('[')===true){
                        adr=sj0.slice(1,-1);
                        adr_int=parseInt(adr,16);
                        ca=0;
                        sta=insertText(`<input class="mem_check_meta" ln="${c}" title="${adr}" meta_mem="${cm}" onclick="chkClick_mem(event,true);" type="checkbox"></input>`,sta,sj);
                        cm++;
                    }else{
                        let ai=adr_int+ca;
                        let aix=ai.toString(16).toUpperCase();
                        sta=insertText(`<input class="mem_check_byte" ln="${c}" title="${aix}" address="${aix}" mem_ix="${mem_ix}" meta_mem="${cm-1}" onclick="chkClick_mem(event);" type="checkbox"></input>`,sta,sj);
                        ca++;
                        mem_ix++;
                    }
                }
                strs_last=null;
                ca=null;
                adr=null;
                adr_int=null;
                inst=sta.join('');
                sta=null;
                c++;
            }
                
				insts.push(inst);
		}
		}
		pre_el.innerHTML=insts.join('');
		let nts=pre_el.querySelectorAll('div.notes');
        ntes=[];
        for(let k=0, len_k=nts.length;k<len_k;k++){
                let nk=nts[k];
                let ln=parseInt(nk.getAttribute('ln'));
                ntes[ln]=nk;
            }
        
        //click on meta mem - all byte ixs for each
        	let ckbt=pre_el.getElementsByClassName('mem_check_byte');
            let ckbs=[];
            for(let k=0, len_k=ckbt.length;k<len_k;k++){
                let ckb=ckbt[k];
                let m=parseInt(ckb.getAttribute('meta_mem'));
                let x=parseInt(ckb.getAttribute('mem_ix'));
               if (typeof(meta_mems[m])==='undefined'){
                meta_mems[m]=[ckb];
               }else{
                meta_mems[m].push(ckb);
               }
               ckbs[x]=ckb;
            }
            
            	let ckm=pre_el.getElementsByClassName('mem_check_meta');
        
            for(let k=0, len_k=ckm.length;k<len_k;k++){
                let ckmk=ckm[k];
                let m=parseInt(ckmk.getAttribute('meta_mem'));
                meta_mems[m].unshift(ckmk); //1st el is meta checkbox
            }
            
  //sorted array for each address
for(let k=0, len_k=ckbs.length;k<len_k;k++){
    let cs=ckbs[k];
    let a=cs.getAttribute('address');
    if(typeof(mems_chk[a])==='undefined'){
        mems_chk[a]=[cs];
        ckbs[k].setAttribute('addr_ix',0);
    }else{
        mems_chk[a].push(cs);
        ckbs[k].setAttribute('addr_ix',mems_chk[a].length-1);
    }
}
        
        let ck=pre_el.getElementsByClassName('reg_check');
		for(let k=0, len_k=ck.length;k<len_k;k++){
			let ckk=ck[k];
			let x=parseInt(ckk.getAttribute('ovr_occ'));
            allChk[x]=ckk;
		}
	
	}
		
 rvc.addEventListener('input',  function () {
	 chkRev=rvc.checked;
 });
 
 document.getElementById("openFile1").addEventListener('change',  function () {
	 chkRev=rvc.checked;
	 var fr = new FileReader();
	 fr.onload = function () {
		let str = this.result;
		isRN=(str.split('\r\n').length>=str.split('\n').length)?true:false;
		if(firstDone===true){
		for (let k=0; k<registers['list_regs_len']; k++){
			let rk=registers['list_regs'][k];
			let rk_obj=rk.at(-1);
			if(typeof(rk_obj)==='object'){
				rk_obj.occs=[];
			}
		}
		chkCnt=0;
		allChk=[];
        meta_mems=[];
        mems_chk={};
		proc(str);
		}else{
			proc(str);
			firstDone=true;
		}
		
	}
	fr.readAsText(this.files[0]);
}); 
 </script>
</body>
</html>